<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS高级(5)]]></title>
    <url>%2F2017%2F06%2F27%2FJS%E9%AB%98%E7%BA%A7-5%2F</url>
    <content type="text"><![CDATA[闭包概念闭包指的就是那些能够访问独立的变量的函数！ 闭包要解决的问题函数中声明的变量不能被函数外部直接使用 闭包的基本模型1234567function outer()&#123; var data = ""; function inner()&#123; //操作data &#125; return inner;&#125; 使用闭包设置和获取变量的值123456789101112function outer()&#123; var data = ""; var obj = &#123; setData: function(value)&#123; data = value; &#125;, getData: function()&#123; return data; &#125; &#125; return obj;&#125; 闭包的原理就是作用域的访问规则！ 闭包的作用 给函数提供一个私有的变量 保护变量，给变量的设置提供专有的渠道，在这个渠道中可以添加一些校验的逻辑 缓存 浏览器缓存 CDN 硬件缓存 缓存封装1234567891011121314function createCache()&#123; var cache = &#123;&#125;; var keys = []; return function(key, value)&#123; if(value)&#123; cache[key] = value; if(keys.push(key) &gt; 20)&#123; delete[keys.shift()]; &#125; &#125;else&#123; return cache[key]; &#125; &#125;&#125; jQuery缓存源码123456789function createCache()&#123; var keys = []; function cache(key, value)&#123; if(keys.push(key + " ") &gt; 20)&#123; delete cache[keys.shift()]; &#125; return (cache[key + " "] = value); &#125;&#125; 递归实现的斐波那契数列存在的性能问题由于存在大量的重复的计算，所以导致在40多之后，就算不出来了123456function fib(n)&#123; if(n==1 || n==2)&#123; return 1; &#125; return fib(n-1) + fib(n-2); //每个分支下都会执行到 n==1或者n==2的时候 即使之前已经被计算出结果&#125; 解决方案 提供一个缓存，用这个缓存来存储计算出来的数据 每次在计算的时候，首先先从缓存中去获取,如果有，就直接返回 如果没有，就通过递归的方式去计算 计算出来之后，一定要记着保存到缓存中去，以便下次使用 1234567891011121314151617181920212223242526272829function createCache()&#123; var cache = &#123;&#125;; var keys = []; return function(key, value)&#123; if(value)&#123; cache[key] = value; if(keys.push(key) &gt; 20)&#123; delete[keys.shift()]; &#125; &#125;else&#123; return cache[key]; &#125; &#125;&#125;var cache = createCache();function fib(n)&#123; var num = cache(n); if(!num)&#123; if(n == 1 || n == 2)&#123; num = 1; &#125;else&#123; num = fib(n - 1) + fib(n - 2); &#125; cache(n, num); &#125; return num;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS高级(4)]]></title>
    <url>%2F2017%2F06%2F26%2FJS%E9%AB%98%E7%BA%A7-4%2F</url>
    <content type="text"><![CDATA[伪数组拥有数组通过数字作为下标访问元素的特征，并且拥有length属性，但是没有数组方法的对象就称作伪数组 arguments对象arguments对象是函数中的一个伪数组，在函数被调用的时候，会把所有的实参存到这个伪数组当中 属性 length: 传入的实参的个数 callee: arguments对象所在的函数，一般被用来实现递归！ 如何通过arguments对象实现重载？重载: 参数不同 实现不同的功能1234567891011121314function test()&#123; switch(arguments.length)&#123; case 1: break; case 2: break; case 3: break; case 4: break; case 5: break; &#125;&#125; 递归概念函数中直接或者间接的调用自己 两大要素 自己调用自己 结束条件 化归思想化归思想，将一个问题由难化易，由繁化简，由复杂化简单的过程称为化归，它是转化和归结的简称。 递归解决数学问题 前n项和 n! 求幂 求斐波那契数列的第n项 递归获取后代元素 先获取元素的所有的子元素 再去获取子元素的子元素，依次递归就可以获取到所有的后代元素123456789101112131415161718192021var list = [];function getChildren(ele)&#123; var children = ele.children; for(var i = 0; i &lt; children.length; i++)&#123; var child = children[i]; list.push(child); getChilren(child); &#125;&#125;function getChildren(ele)&#123; var list = []; var children = ele.children; for(var i = 0; i &lt; children.length; i++)&#123; var child = children[i]; list.push(child); var temp = getChilren(child); list = list.concat(temp); &#125; return list;&#125; 作用域变量起作用的范围 JS里面只有function（函数）可以创建作用域 JS中的作用域是词法作用域（静态作用域）变量的作用域只和函数的声明位置有关，和函数的调用无关！代码在写出来之后，就可以根据代码的书写结构确定变量的作用域，而不需要关心具体的运行的时候的状况。123456789var num = 123;function f1()&#123; console.log(num);&#125;funciton f2()&#123; var num = 456; f1();&#125;f2(); 块级作用域： js中没有块级作用域， 块级作用域就是代码块限定的作用域！ 作用域链函数可以创建作用域，函数中又可以声明函数，这样就形成了作用域嵌套作用域的链式访问结构，叫做作用域链！ 变量搜索原则当使用一个变量的时候 现在当前使用该变量的作用域中进行查找，找该变量的声明，如果有，就直接使用 如果没有就去上一级作用域中进行查找，找该变量的声明，如果有，就直接使用 如果没有，就继续沿着作用域链向上查找，直到找到全局作用域为止 变量提升js代码执行分两个阶段 预解析阶段 执行阶段 在预解析阶段，系统会将所有的变量声明，以及函数声明提升到其所在的作用域的最顶上，这个过程就叫做变量提升。 变量提升的特殊情况 函数同名： 都提升，后面的会把前面的覆盖掉 函数和变量同名： 只提升函数声明，忽略掉变量声明 变量提升是分作用域的，变量和函数的声明，只会被提升到其所在的作用域的最顶上 变量提升是分段(script标签)的， 在当前script标签中的声明，只会被提升到当前script标签的最顶上，不会跨标签提升 条件式函数声明（在条件语句中声明的函数）：会被当做函数表达式来处理，只提升函数名，不提升函数体！ （条件式函数声明不推荐使用！） 函数的形参： 在预解析之前，就已经完成了函数的形参的声明以及赋值，所以形参的声明和赋值不参与变量提升！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>categories</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高级(3)]]></title>
    <url>%2F2017%2F06%2F24%2FJS%E9%AB%98%E7%BA%A7-3%2F</url>
    <content type="text"><![CDATA[原型链对象都有原型，原型也是对象，原型也有原型，这样就形成了原型组成链条结构，称为原型链。 Object.prototypeObject.prototype是js中所有对象的原型链的最终一环，null标志着原型链的结束！Object.prototype中的所有的成员可以被js中所有的对象共享！ 属性搜索原则当使用对象访问一个属性的时候 现在对象本身进行查找，如果有，就直接使用 如果没有，就去对象的原型中进行查找，如果有，就直接使用 如果没有，就继续沿着原型链向上查找，直到找到为止，或者找到null为止 Object.prototype的成员 名称 说明 hasOwnProperty 判断对象本身是否拥有某个属性, 对象.hasOwnProperty(属性名) isPrototypeOf 判断当前对象是不是另外一个对象的原型 对象.isPrototypeOf(对象) propertyIsEnumerable 判断属性是否属于对象本身并且可以被for-in遍历 对象.propertyIsEnumerable(属性名) toString toLocaleString 将对象转换成字符串的，toLocaleString会将对象转成本地格式的字符串 valueOf 获取对象的值，一般用在值类型和引用类型运算的时候 函数的创建方式函数声明1function 函数名()&#123;&#125; 函数表达式1var 函数名 = function()&#123;&#125;; Function1var 函数名 = new Function(); Function不传参创建出来的是一个空函数，没有任何的功能1var func = new Function(); 传一个参数12var func = new Function(methodBody);//methodBody是一个字符串，里面是符合js语法规范的js代码！会被作为函数体创建新的函数！ 传多个参数123var func = new Function(arg1, arg2...argN, methodBody);//arg1...argN 都是形参的名称， 是字符串！//methodBody是一个字符串，里面是符合js语法规范的js代码！会被作为函数体创建新的函数！ eval()eval可以将字符串转换成代码并直接执行， Funciton创建出来的是函数，需要调用才能执行！ 解析JSON格式的字符串123456789//如果直接将json格式的字符串传递给eval使用，eval会把&#123;&#125;当做代码块处理，报错！var jsonStr = '&#123;"name": "吴彦祖", age: 18&#125;';//解决办法：//1. 把变量的声明也作为字符串传递给evaleval("var obj = " + jsonStr);//2. 在json格式的字符串前后拼接()var o = eval("(" + jsonStr + ")"); Function和eval都有安全性问题！一般情况下不会使用这两个东西！ 函数的原型链函数也是一个对象，函数的构造函数是Function，所以可以分析出函数的原型链 函数 —-&gt; Function.prototype —&gt; Object.prototype —&gt; null 完整的原型链将对象的原型链和函数的原型链结合在一起就绘制成完整的原型链 绘制步骤 绘制对象的原型链 1.1. 绘制对象的构造函数 1.2. 绘制对象的构造函数的原型 1.3. 绘制对象本身 1.4. 绘制3者的三角关系 1.5. 继续沿着构造函数的原型链向上绘制，直到null为止 将构造函数当做对象，绘制函数的原型链 2.1. 绘制函数的构造函数Function 2.2. 绘制Function.prototype 2.3. 绘制3角关系 2.4. 继续沿着Function.prototype的原型向上绘制，直到null为止 绘制Object构造函数 3.1 找到Object构造函数和Object.prototype之间的关系绘制 3.2 将Object当做对象，找到和其构造函数Function的关系，以及原型的关系 将Function当做对象，绘制其原型链 instanceof 关键字12345678910对象A instanceof 构造函数B//判断 构造函数B.prototype是不是在 对象A 的原型链上//Object ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; nullconsole.log(Object instanceof Function);console.log(Object instanceof Object);//Function ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; nullconsole.log(Function instanceof Object);console.log(Function instanceof Function); 函数的成员 name : 函数的名称 length: 函数的形参的个数 caller： 函数是在哪个函数中被调用的，caller就指向那个外部函数（这个caller必须要在函数中去使用，才能访问到值！） arguments： 函数在被调用的时候，会把所有的实参存到这个对象里面（这个对象必须要在函数中去使用，才能访问到值！ 这个arguments是函数的属性，和之前学过的arguments不一样！） 静态成员和实例成员 静态成员： 通过构造函数访问的成员就是静态成员 实例成员： 通过实例对象访问的成员就是实例成员]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS高级(2)]]></title>
    <url>%2F2017%2F06%2F24%2FJS%E9%AB%98%E7%BA%A7-2%2F</url>
    <content type="text"><![CDATA[面向对象编程举例 初步实现（面向过程的方式） 函数封装 对象封装创建对象的方式 字面量12345678var obj = &#123; key: value, key1: value1&#125;;//$().css(&#123;&#125;)//$.ajax(&#123;&#125;)//复用性差 内置构造函数 1234var obj = new Object();obj.key = value;obj.key1 = value1;//复用性差 自定义构造函数 123456function Person()&#123; this.key = value; this.key1 = value1;&#125;var p = new Person(); 构造函数什么是构造函数构造函数就是一个函数，他和普通函数的区别在于，他一般被用来初始化对象！！ 构造函数的特点 首字母大写 一般和new关键字一起使用 不需要写return语句，默认返回new创建出来的对象 构造函数的执行过程 使用new关键字创建对象 调用构造函数，将构造函数中的this指向new创建出来的对象 执行构造函数中的代码，通过this为创建的对象新增属性和方法 默认的返回了new创建出来的对象 构造函数的注意事项 如果手动给构造函数写了return语句 如果return的是值类型的数据，对默认返回值不会有任何影响 如果return的是引用类型的数据，则返回的是该引用类型的数据 如果把构造函数当做普通函数来调用 this会指向window 返回值会和普通函数一样 构造函数写法存在的问题12345678910111213141516171819function Person()&#123; this.name = ""; //每次创建对象都会重新执行一次函数声明，也就是创建一个新的函数 //每个对象中都会有这么一个方法，但是每个方法的功能都是一样的，所以造成资源浪费 this.sayHello = function()&#123; &#125;;&#125;//解决方案：// 将方法的声明提出来放到构造函数外面，每次给对象的方法赋值的时候，直接将外面声明好的函数直接赋值给对象的方法，这样，所有的对象就都共享同一个方法了function sayHello()&#123;&#125;funciton Person()&#123; this.name = ""; this.sayHello = sayHello;&#125;//这么解决会造成全局变量污染以及代码结构混乱的问题 原型原型的概念构造函数在创建出来的时候，系统会默认的帮构造函数创建并且关联一个空对象，这个对象就是原型 原型的作用在原型中的所有的属性和方法，可以被和其关联的构造函数创建出来的所有的对象共享！ 原型的访问方式 构造函数.prototype 对象.proto (有兼容性问题) 原型的使用方式 利用对象的动态特性，给系统创建好的默认的原型中新增属性和方法 1Person.prototype.name = ""; 直接给构造函数.prototype属性赋值一个新的对象！ 原型的使用注意事项 一般将需要共享的内容放在原型当中，对象特有的东西放在对象本身中 使用对象.属性获取对象的属性的时候，会先在对象本身进行查找，如果有就使用，如果没有，就会去原型中进行查找 使用对象.属性 = 值，给对象的属性赋值的时候，会直接在直接在对象本身进行查找，如果有，就修改，如果没有，就新增这个属性 在使用构造函数.prototype=新的对象的时候， 赋值之前创建的对象和赋值之后创建的对象的原型不一样 面向对象的三大特性 封装：将功能的具体实现封装在对象内部，只对外界暴露指定的接口，外界在使用的时候，只需要关心接口如何使用，而不需要关心对象内部功能的具体实现，这就是封装 （ATM，电脑） 继承：自己没有的东西，别人有，拿过来使用，就是继承（js中的继承是基于对象的！） 多态：js中没有多态！ 继承的实现方式 混入式继承（mix-in） 123456789var obj = &#123;&#125;;var obj1 = &#123; name: "", age: 18&#125;for(var k in obj1)&#123; obj[k] = obj1[k];&#125; 原型继承 直接将要继承的对象，赋值给构造函数的prototype属性，这样创建出来的所有的对象能够访问的原型就是这个要继承的对象，也就是说实现了继承！ 123456789function Person()&#123; &#125;var obj = &#123; name: "", age: 18&#125;Person.prototype = obj; 利用混入的方式，将要继承的对象中的所有的方法和属性，添加到构造函数默认的原型中去 12345678910function Person()&#123; &#125;var obj = &#123; name: "", age: 18&#125;for(var k in obj)&#123; Person.prototype[k] = obj[k];&#125; 经典继承 123456789101112131415161718//Object.createvar obj1 = &#123; name: "", age: 18&#125;var obj = Object.create(obj1);//创建出来一个新的对象obj，obj的原型就是obj1function myCreate(obj)&#123; if(Object.create)&#123; return Object.create(obj); &#125;else&#123; function F()&#123;&#125; F.prototype = obj; return new F(); &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS高级(1)]]></title>
    <url>%2F2017%2F06%2F24%2FJS%E9%AB%98%E7%BA%A7-1%2F</url>
    <content type="text"><![CDATA[JavaScript的组成 DOM: Document Object Model 提供了一整套操作页面元素的API BOM: Browser Object Model 提供了一整套操作浏览器相关内容的API ECMAScript: js的语法规范以及标准！ JavaScript中的数据类型基本数据类型 string number boolean 复合数据类型 Object function Array Date RegExp String Number Boolean Math 空类型 null undefined 获取数据类型的方式1234567var res = typeof 数据;//typeof关键字可以用来获取数据的数据类型，他的返回值表示数据的数据类型，返回值是一个字符串类型的值//typeof关键字获取除了function以外所有的引用类型的数据的类型的时候，获取到的都是 object//typeof null 获取到的是 object//typeof undefined 获取到的是 undefined 全等和等于的区别全等即判断数据的数据类型是否一致，也判断值是否一致 等于只判断值是否一样 引用类型和值类型参与运算的时候的规则12345678console.log([] == ![]);//1. console.log([] == false);//2. console.log([].valueOf() == false);//3. console.log([].toString() == false);//4. console.log("" == false);console.log(&#123;&#125; + 1);console.log(&#123;&#125; == !&#123;&#125;); 当值类型和数据和引用类型的数据发生运算的时候，首先需要调用该引用类型数据的valueOf方法，获取返回之后，尝试进行运算，如果可以运算，则得出结果，如果不能运算，继续调用该引用类型数据的toString方法，获取返回值，参与运算！ in关键字的使用for-in 用来遍历对象的属性123for(var k in obj)&#123; console.log(k); //k 代表的就是对象的属性，这个k是字符串类型&#125; 属性名 in 对象 判断对象能否访问指定的属性12var obj = &#123;name: "xyz"&#125;;console.log("name" in obj); delete关键字的使用删除没有使用var声明的变量1delete 变量名; 删除对象的属性12delete 对象名.属性delete 对象名[属性] tip: 访问一个不存在的变量，会报错，xx is not defined访问一个对象不存在的属性，不会报错，会返回undefined 逻辑中断||中断12表达式1||表达式2//如果表达式1为真，则返回表达式1，否则返回表达式2 &amp;&amp; 中断12表达式1&amp;&amp;表达式2//如果表达式1为假，则返回表达式1，否则返回表达式2 break和continuebreak 跳出整个循环，继续执行循环之后的代码continue 跳出本次循环， 执行下次循环异常处理语句123456789try&#123; //可能出现错误的代码&#125;catch(e)&#123; //出错后的处理代码 //e 就出错的错误信息&#125;finally&#123; //无论是否出错都会执行的代码 //一般情况下放释放资源的代码&#125; 手动抛出异常12throw anything;//throw可以手动抛出异常，可以抛出任何东西，throw出去的内容如果有trycatch语句，就会被catch捕获，catch中的e就是我们跑出去的异常信息 引用类型和值类型值类型存储的是数据本身的这种数据，就是值类型的数据 引用类型存储的是数据的地址，数据单独存储，这种数据，就是引用类型的数据 值类型和引用类型的赋值特征值类型值类型赋值，会将当前变量存储的数据直接复制一份交给新的变量，此时两个变量内容相同，但是存储空间完全独立，互不影响 引用类型赋值， 会将当前变量存储的数据的地址复制一份，交给新的变量，两个变量指向同一个对象，修改其中一个，另外一个也受到影响 对象的动态特性在对象创建完成之后，可以随时为对象新增成员（属性和方法）这种特性就是动态特性 面向对象的基本概念面向过程解决问题的思维方式， 将解决问题的关注点方法在了解决问题的每一个详细的步骤上！ 面向对象解决问题的思维方式， 将解决问题的关注点方法在了解决问题所需要的一系列的对象身上！ 面向对象和面向过程的关系面向对象其实就是对面向过程的封装 什么是对象万物皆对象js中，无序的键值对集合，就是对象！]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>对象</tag>
        <tag>数据类型</tag>
        <tag>遍历</tag>
        <tag>异常</tag>
      </tags>
  </entry>
</search>